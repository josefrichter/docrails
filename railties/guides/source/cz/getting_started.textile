h2. Začínáme s Rails

Tento průvodce popisuje jak začít s Ruby on Rails. Po jeho přečtení byste měli chápat následující:

* Instalace Rails, vytvoření nové Rails aplikace a propojení aplikace s databází
* Obecná struktura Rails aplikace
* Základní principy MVC (Model, View, Controller) a designu založeného na REST přístupu
* Jak rychle vytvořit základní části Rails aplikace

endprologue.

WARNING. Tento průvodce popisuje Rails verze 3.0. Některé části kódu zde uvedené nebudou fungovat v předchozích verzích Rails.

h3. Předpoklady tohoto průvodce

Tento průvodce je navržen pro začátečníky, kteří chtějí začít s Rails aplikací od úplného začátku. Nepředpokládá že máte jakoukoliv předchozí zkušenost s Rails. Nicméně abyste z něj vytěžili co nejvíce, potřebujete mít nainstalovány některé náležitosti:

* Jazyk "Ruby":http://www.ruby-lang.org/en/downloads verze 1.8.7 nebo vyšší

TIP: Ruby 1.8.7 p248 a p249 obsahují chybu, která shazuje Rails 3.0. Ruby Enterprise Edition ale mají tuto chybu opravenu od verze 1.8.7-2010.02. Pokud jde o verzi 1.9, pak Ruby 1.9.1 není použitelné, protože okamžitě selhává při spojení s Rails 3.0, takže pokud chcete používat Rails 3 s verzí 1.9.x použijte 1.9.2 pro hladký průběh.

* Balíčkovací systém "RubyGems":http://rubyforge.org/frs/?group_id=126
* Funkční instalaci databáze "SQLite3":http://www.sqlite.org

Rails je webový aplikační framework bežící na programovacím jazyku Ruby. Pokud nemáte žádnou předchozí zkušenost s Ruby, může pro Vás být náročnější ponořit se přímo do Rails. Na webu je několik dobrých bezplatných zdrojů k naučení základů jazyka Ruby, včetně následujících:

* "Mr. Neighborly's Humble Little Ruby Book [anglicky]":http://www.humblelittlerubybook.com
* "Programming Ruby [anglicky]":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby [anglicky]":http://mislav.uniqpath.com/poignant-guide/ 
* "Ruby v příkladech [česky]":http://www.root.cz/serialy/ruby-v-prikladech/
* "Ruby po kapkách [česky]":http://interval.cz/programovani/ruby/

h3. Co jsou Rails?

Rails jsou webový aplikační vývojový framework napsaný v jazyce Ruby. Je navržen tak, aby zjednodušil programování webových aplikací tím, že činí předpoklad o tom, co každý vývojář potřebuje aby začal. Umožňuje vám psát méně kódu a zároveň dosáhnout více než v mnoha jiných jazycích a frameworcích. Zkušení Rails vývojáři také říkají, že Rails dělají vývoj webových aplikací zábavnějším.

Rails jsou umíněný software. Činí předpoklady, že existuje "nejlepší" způsob dělání věcí a jsou navrženy aby takový způsob podporovaly - a v některých případech odrazovaly od alternativních způsobů. Pokud se naučíte "Rails přístup", pravděpodobně pocítíte výrazný nárúst produktivity. Pokud budete trvat na přenášení si starých zvyků z jiných jazyků a budete se pokoušet aplikovat postupy naučené jinde, váš zážitek může být poněkud méně veselý.

Filozofie Rails zahrnuje několik navádějících principů:

* DRY - "Don't repeat yourself" = neopakujte se - naznačuje, že psát stejný kód stále dokola je špatně.
* Konvence nad konfigurací - znamená, že Rails činí předpoklady o tom, co chcete udělat a jak to chcete udělat, místo aby vás nutily specifikovat každou jednu věc v nekonečných konfiguračních souborech.
* REST je nejlepší vzorec pro webové aplikace - uspořádávat vaši aplikaci kolem zdrojů a standardních HTTP příkazů je nejrychlejší způsob.

h4. Architektura MVC

V srdci Rails je ukotvena architektura Model, View, Controller, obvykle označována jen jako MVC. Výhody MVC jsou například:

* oddělení aplikační logiky od uživatelského rozhraní
* jednoduchost udržování kódu bez opakovaných součástí (DRY code)
* ujasnění kam různé části kódu patří, kvůli snadnější údržbě

h5. Models (modely)

Model reprezentuje informace (data) aplikace and pravidla pro práci s nimi. V případě Rails jsou modely užívány zejména pro správu pravidel interakce s příslušnou databázovou tabulkou. Ve většině případů bude jedna tabulka v databázi odpovídat jednomu modelu vaší aplikace. Kus vaší aplikační logiky bude koncentrován v modelu. 

h5. Views (pohledy)

Views reprezentují uživatelské rozhraní vaší aplikace. V rails jsou views obvykle HTML soubory s vloženým Ruby kódem, který provádí úkony související čistě s přezentací dat. Views mají na starosti poskytovat data webovému prohlížeči nebo jinému nástroji použitému k zasílání požadavků vaší aplikaci.

h5. Controllers (řadiče)

Controllery tvoří "lepidlo" mezi modely a views. V Rails jsou controllery zodpovědná za zpracování příchozích požadavků z webového prohlížeče, získávání dat z modelů a odesílání těchto dat do views k jejich zobrazení.  

h4. Komponenty Rails

Rails jsou poskládány z mnoha jednotlivých komponent.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties


h5. Action Pack

Action Pack je jediný gem, který obsahuje Action Controller, Action Dispatch a Action View. Je to VC část MVC.

h5. Action Controller

Action Controller je komponenta, která má na starosti controllery v Rials aplikaci. Action Controller framework zpracovává příchozí požadavky v Rails aplikaci, vytahuje z nich parametry a rozesílá je příslučným akcím. Služby poskytované Action Controllerem zahrnují správu relací (sessions), vykreslování šablon a správu přesměrování.     

h5. Action View

Action View má na startosti views vaší Rails aplikace. Umí v základu vytvořit výstup jak v HTML tak v XML. Action View řídí vykreslování šablon, včetně vnořených a parciálních šablon, a obsahuje zabudovanou podporu AJAXu.    

h5. Action Dispatch

Action Dispatch zpracovává směrování příchozích požadavků a rozesílá je tam kam chcete, buďto do vaší aplikace anebo do jakékoliv jiné Rack aplikace.

h5. Action Mailer

Action Mailer je framework pro tvorbu e-mailových služeb. Action Mailer můžete použít pro příjem a zpracování příchozích e-mailů a odesílání jednoduchých čistě textových anebo složitých multipart emailů na základě flexibilních šablon.

h5. Active Model

Active Model poskytuje definované rozhraní mezi službami gemu Action Pack a ORM gemy (Object Relational Mapping - objektově relační mapování) jako například Active Record. Active Model umožňuje Rails využívat jiné ORM frameworky místo Active Recordu, pokud to vaše aplikace potřebuje.

h5. Active Record

Active Record je základem pro modely v Rails aplikaci. Umožňuje mimo jiné nezávislost na databázi, základní CRUD (create,read,update,delete - vytvořit, načíst, upravit, smazat) funkcionalitu, pokročilé vyhledávací schopnosti, a schopnost specifikovat vztahy (relace) mezi modely.

h5. Active Resource

Active Resource poskytuje rámec pro správu spojení mezi aplikační logikou a REST službami. Implementuje způsob mapování webových zdrojů na lokální objekty s CRUD sémantikou.

h5. Active Support

Active Support je rozsáhlá kolekce podpůrných funkcí a rozšíření základní knihovny Ruby, které jsou využívány v Rails jak interním kódem tak vašimi aplikacemi.

h5. Railties

Railties jsou srdcem Rails kódu, který vytváří novou Rails aplikaci a propojuje jednotlivé frameworky a pluginy v rámci Rails aplikací.

h4. REST

REST je zkratka pro Representational State Transfer a je základem REST architektury. Ta je obecně považována za disertační práci Roye Fieldinga "Architektonické styly a navrhování architektury síťového software [anglicky]":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm. Sice si můžete pročíst celou práci, ale v Rails se REST koncentruje do dvou hlavních principů:

* Používání identifikátorů zdrojů, jako například URL, pro reprezentaci zdrojů
* Přenášení reprezentace stavu těchto zdrojů mezi systémovými komponentami.

Například v Rails aplikaci bude požadavek typu 

<tt>DELETE /photos/17</tt>

chápán jako odkazující na zdroj-fotografii s ID=17 a indikující požadovanou akci - smazání zdroje-fotografie. REST je přirozeným stylem architektury webových aplikací a Rails se jím řídí aby vás odstínily od mnohých komplexních problémů souvisejících s REST a podivností prohlížečů.

Pokud by vás zajímalo více podrobností o REST jako architektonickém stylu, následující zdroje jsou snadněji stravitelné než Fieldingova disertace:

* "A Brief Introduction to REST [anglicky]":http://www.infoq.com/articles/rest-introduction od Stefana Tilkova
* "An Introduction to REST [anglicky]":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) od Joe Gregoria
* "Representational State Transfer [anglicky]":http://en.wikipedia.org/wiki/Representational_State_Transfer článek na Wikipedii
* "How to GET a Cup of Coffee [anglicky]":http://www.infoq.com/articles/webber-rest-workflow od Jima Webbera, Savase Parastatidise & Iana Robinsona

h3. Vytvoření nového Rails projektu

Následováním této příručky, vytvoříte (velmi) jednoduchý <tt>blog</tt> v Rails. Předtím ale, než začneme vytvářet aplikaci, musíte se ujistit, že máte Rails správně nainstalované.

h4. Instalace Rails

Ve většině případů je nejjednodušší cestou pro nainstalování Rails využítí výhod RubyGems:

<shell>
Obvykle stačí spustit tento příkaz jako root:
# gem install rails
</shell>

TIP. Pokud pracujete na Windows, mějte na vědomí, že velká většina Rails vývoje probíhá v Unixových systémech. I když samotné Ruby on Rails jdou nainstalovat snadno pomocí například "Ruby Installer":http://rubyinstaller.org/, podpůrný ekosystém často předpokládá, že je schopni zkompilovat rubygems na bázi C-jazyků a pracovat v příkazové řádce. Pokud je to možné, doporučujeme nainstalovat virtuální stroj s operačním systémem Linux a vyvíjet Rails v něm, místo používání Windows.

h4. Vytvoření aplikace Blog

Nejlepší cesta, jak používat tuto příručku je řídit se dle pokynů v ní. Nebyl vynechán jediný krok, nebo část kódu, který je pro vytvoření aplikace potřeba, takže ji můžete následovat krok za krokem. Pokud se potřebujete podívat na celý kód, můžete si ho stáhnout z "Getting Started Code":http://github.com/mikel/getting-started-code.

Na začátku si otevřete terminál a jdetě do složky, kde máte práva vytvářet soubory a napište:

<shell>
$ rails new blog
</shell>

Toto vytvoří Rails aplikaci nazvanou Blog ve složce s názvem blog.

TIP: Můžete se podívat na všechny parametry, které generátor Rails aplikace přijímá zavoláním <tt>rails -h</tt>.

Poté co vytvoříte aplikaci blog, přejděte do jejího adresáře pro pokračování s další prací:

<shell>
$ cd blog
</shell>

Rails vytvoří složku v aktuálním adresáři pojmenovanou <tt>blog</tt>. Otevřete ji a prozkoumejte její obsah. Většina úkonů v tomto tutoriálu bude prováděna ve složce <tt>app/</tt>, ale zde je základní popis jednotlivých funkcí všech dalších složek, které Rails vytvoří s novou aplikací:

|_.Soubor/Složka|_.Účel|
|Gemfile|Tento soubor vám umožní specifikovat jaké gemy potřebujete pro vaší Rails aplikaci.|
|README.rdoc|Toto je stručný návod k aplikaci. Použijte ho, abyste ostatním řekli, co aplikace dělá, jak ji nastavit atd.|
|Rakefile|Tento subor obsahuje dávkové úlohy, které je možné spustit z terminálu.|
|app/|Obsahuje kontrolery (controllers), modely (models) a pohledy (views). Na tuto složku se budete soustředit po zbytek příručky.|
|config/|Konfigurace běhu aplikace, cesty (routes), databáze a mnoho dalšího.|
|config.ru|Rack konfigurace pro Rack servery používaná pro spuštění aplikace.|
|db/|Aktuální schéma databáze a databázové migrace. Ty popíšeme záhy.|
|doc/|Podrobná dokumentace pro vaší aplikaci|
|lib/|Rozšiřující moduly pro vaší aplikaci (není dále popsáno v této příručce).|
|log/|Aplikační log soubory.|
|public/|Jediná složka, která je přístupná z venku. Zde se ukládájí obrázky, javascripty, styly (CSS) a další statické soubory.|
|script/|Obsahuje skript rails, který spouští vaší aplikaci a může obsahovat další, které slouží například pro deploy.|
|test/|Unit testy, fixtures a jiné testovací nástroje. Ty jsou popsány v "Testování Rails aplikací":testing.html|
|tmp/|Dočasné soubory|
|vendor/|Místo pro zdrojové soubory třetích stran. V typické Rails aplikaci to jsou například Ruby Gems, zdrojový kód Rails a pluginy rozšiřující funkcionalitu.|

h4. Instalování potřebných Gemů

Rails aplikace v základu spravuje závislosti gemů pomocí "Bundleru":http://gembundler.com/v1.0/index.html. Protože nepotřebujeme jiné gemy, než ty, které jsou zahrnuty ve vygenerovaném +Gemfile+, můžeme přímo spustit

<shell>
bundle install
</shell>

pro jejich nainstalování.

h4. Konfigurace databáze

Pravděpodobně každá vaše Rails aplikace bude komunikovat s databází. Jaká databaze se použije je nastaveno v konfiguračním souboru, +config/database.yml+. Pokud otevřete tento soubor v nové Rails aplikaci, uvidíte základní konfiguraci databáze používající SQLite3. Soubor obsahuje sekce pro tři rozdílná prostředí v kterých mohou být Rails v základu puštěny:

* Prostředí +development+ je používáno na počítači, kde aplikaci vyvíjíte a pracujete s ní.
* Prostředí +test+ je používáno pro automatizované testy.
* Prostředí +production+ je používáno v momentě, kdy je aplikace nasazena na server a spuštěna pro reálné použítí.

h5. Konfigurace databáze SQLite3

Rails přicházejí s vestavěnou podporou pro "SQLite3":http://www.sqlite.org, což je lehká databáze nepotřebující server ke svému běhu. V produkci by ovšem mohla být snadno přetížena, proto je vhodá pro použítí při vývoji a testování. Rails aplikace je v základu vytvořena s nastavením pro SQLite, ale můžete to kdykoli později změnit.

Tady je sekce základního souboru s konfigurací (<tt>config/database.yml</tt>) s informacemi pro připojení v prostředí development:

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: V této příručce používáme SQLite3 databázi pro ukládání dat, jelikož nepotřebuje žádnou dodatečnou konfiguraci. Rails také podporují MySQL a PostgreSQL "out of the box" a existují pluginy pro další databázové systémy. Jestliže využíváte databázi v produkčním prostředí, Rails bude mít správný adaptér pro připojení.

h5. Konfigurace databáze MySQL

Pokud chcete použít MySQL namísto implicitní databáze Sqlite3, váš +config/database.yml+ bude vypadat trochu odlišně. Tady je část pro prostředí development:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Pokud máte na vašem vývojovém počítači instalaci MySQL s uživatelem root a prázdným heslem, tak konfigurace bude fungovat. V opačném případě v ní změnte jméno a heslo podle potřeby v sekci +development+.

h5. Konfigurace databáze PostgreSQL

A konečně pokud se rozhodnete pro použití PostgreSQL, +config/database.yml+ bude upraven následujícím způsobem:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

Změnte jméno a heslo v sekci +development+ dle potřeby

h4. Vytvoření databáze

Teď, když máme databázi nakonfigurovanou, je čas ji vytvořit. Rails jednoduše vytvoří prázdnou databázi spuštěním rake příkazu:

<shell>
$ rake db:create
</shell>

Toto vytvoří databáze SQLite3 s názvy development a test v adresáři <tt>db/</tt>.

TIP: Rake je obecným nástrojem pro spouštění příkazů, který Rails používají na mnoho věcí. Můžete se podívat na seznam dostupných rake příkazů spuštěním +rake -T+.

h3. Ahoj Rails!

Jedním z tradičních způsobů, ja začít s novým programovacím jazykem je zobrazení krátkého textu na obrazovce. Abyste toho docílili, musíte spustit server Rails aplikace.

h4. Spuštění webového serveru

Ve skutečnosti už máte připravenou plně funkční Rails aplikaci. Abyste si ji zobrazili, musíte spustit webový server na vašem vývojovém počítači. Uděláte to následujícím příkazem:

<shell>
$ rails server
</shell>

Ve výchozím nastavení se spustí instance web serveru Mongrel (Rails mohou použít řadu jiných webových serverů). Pro zobrazení aplikace otevřete okno vášeho prohlížeče a jděte na stránku "http://localhost:3000":http://localhost:3000. Měli byste vidět základní informační stránku Rails:

!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: Pro zastavení serveru zmáčkněte Ctrl+C v terminálovém okně, kde server běží. V development módu Rails obvykle nevyžadují zastavení serveru. Jakékoliv změny v souborech, které provedete, server automaticky načte.

Stránka "Welcome Aboard" je jen _zkouška sirén_ pro novou Rails aplikaci: ujišťuje se, že máte vše správně nastaveno pro zobrazení stránky. Můžete táké přejít na odkaz _About your application's environment_ kde najdete shrnutí konfigurace vašeho aplikačního prostředí.

h4. Rails, řekněte "Ahoj"

Aby Rails řekly "Ahoj", musíte vytvořit kontroler (controller) a pohled (view). Naštěstí toto můžete provést spuštěním jediného příkazu. Vložte tedy do terminálu:

<shell>
$ rails generate controller home index
</shell>

TIP: Pokud používáte Windows, nebo máte Ruby nestandardně nainstalované, možná budete muset příkaz pustit s celou cestou k Rails: +ruby \path\to\rails controller home index+.

Rails pro Vás vytvoří několik souborů, včetně +app/views/home/index.html.erb+. Toto je šablona, která bude použita pro zobrazení výsledku akce (action) index v kontroleru (controller) home. Otevřete tento soubor v textovém editoru a upravte ho, aby obsahoval tuto jednoduchou řádku kódu:

<code class="html">
<h1>Ahoj Rails!</h1>
</code>

h4. Nastavení domovské stránky aplikace

Nyní, když jsme vytvořili controller a view, ještě potřebujeme Rails říci, kdy se má "Ahoj, Rails" zobrazit. V našem případě chceme, aby se to zobrazilo na výchozí URL naší stránky, "http://localhost:3000":http://localhost:3000, namísto zkušební stránky "Welcome Aboard".

Prvním krokem je smazání základní stránky z vaší aplikace:

<shell>
$ rm public/index.html
</shell>

Toto musíme udělat, jelikož Rails posílají jakýkoli statický obsah ze složky +public+ přednostně před dynamicky generovaným obsahem z controllerů.

Nyní musíte Rails říci, kde se nachází skutečná domovská stránka. Otevřete soubor +config/routes.rb+ v textovém editoru. To je konfigurace cest (routes) aplikace, které jsou nastaveny speciálním DSL (domain-specific language). Díky tomu Rails ví, jak spojit příchozí požadavky s controllery a akcemi. Tento soubor obsahuje mnoho příkladů v zakomentovaných řádcích. Jeden z nich ukazuje, jak spojit domovskou stránku vaší aplikace s konkrétním controllerem a akcí. Najděte řádek začínající na +root :to+, odkomentujte ho a změňte následovně:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

The +root :to => "home#index"+ říká Rails, že má požadavky směřované na "/" spojit s controllerem home a jeho akcí index.

Pokud si nyní v prohlížeči zobrazíte "http://localhost:3000":http://localhost:3000, uvidíte +Ahoj, Rails!+.

NOTE. Více informací ohledně routování naleznete v "Rails Routing from the Outside In":routing.html.

h3. Rychlý start s použitím nástroje Scaffolding (lešení)

V Rails je _scaffolding_ rychlým způsobem jak vytvořit některé hlavní kusy aplikace. Když chcete vytvořit modely, views a controllery pro nové zdroje v jediném kroku, scaffolding je tím správným nástrojem.

h3. Vytvoření zdroje

V případě blogovací aplikace můžete začít vytvořením scaffold pro zdroj Post (příspěvek): ten bude představovat jednotlivý příspěvek na blogu. Pro jeho vytvoření zadejte v terminálu následující příkaz:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOTE. I když Vám scaffolding pomůže rychle začít, univerzální kód, který vygeneruje, pravděpodobně nebude perfektně vyhovovat Vaší aplikaci. Ve většině případů budete chtít následně poupravit vygenerovaný kód. Mnoho zkušených vývojářů v Rails vůbec scaffolding nepoužívá a upřednostňuje psaní veškerého nebo většiny kódu „z čistého listu.“

Scaffolding generátor vytvoří ve Vaší aplikaci 15 souborů, několik složek, a jeden soubor upraví. Toto je přehled co všechno vytvoří:

|_.Soubor                                       |_.Účel|
|db/migrate/20100207214725_create_posts.rb.rb    |Migrace vytvářející tabulku posts v databázi (u Vás bude název obsahovat jinou časovou značku)|
|app/models/post.rb                           |model Post|
|test/fixtures/posts.yml                      |Uměle vygenerované příspěvky pro účely testování|
|app/controllers/posts_controller.rb          |Posts controller|
|app/views/posts/index.html.erb               |View zobrazující seznam všech příspěvků|
|app/views/posts/edit.html.erb                |View k úpravám existujícího příspěvku|
|app/views/posts/show.html.erb                |View pro zobrazení jednotlivého příspěvku|
|app/views/posts/new.html.erb                 |View pro vytvoření nového příspěvku|
|app/views/posts/_form.html.erb               |Parciální šablona formuláře použitého ve views new a edit|
|app/helpers/posts_helper.rb                  |Pomocné funkce pro předchozí views|
|test/unit/post_test.rb                       |Jednotkové testy posts modelu|
|test/functional/posts_controller_test.rb     |Funkční testy posts controlleru|
|test/unit/helpers/posts_helper_test.rb       |Jednotkové testy posts helperu|
|config/routes.rb                             |Do souboru přidány údaje pro směrování posts|
|public/stylesheets/scaffold.css              |Kaskádové styly zlepšující vzhled scaffoldovaných views|

h4. Spuštění migrace

Jedním z výstupů příkazu +rails generate scaffold+ je _databázová migrace_. Migrace jsou třídy Ruby, jejichž účelem je zjednodušit vytváření nebo úpravy databázových tabulek. Rails používají ke spuštění migrací příkaz rake, a je také možné vrátit zpět migraci, která již byla provedena. Názvy souborů migrací obsahují časovou značku, aby bylo zajištěno, že jsou zpracovány v pořadí, v jakém byly vytvořeny.

Když se podíváte do souboru +db/migrate/20100207214725_create_posts.rb+ (pamatujte, že Váš bude mít mírně odlišný název), uvidíte následující:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

Tato migrace vytváří dvě metody: +up+, volanou když spustíte tuto migraci nad databází, a +down+ v případě, že chcete později vrátit změny, provedené touto migrací na databázi. V tomto případě medtoda +up+ vytvoří tabulku +posts+ se dvěma sloupci formátu string (textový řetězec) a jeden sloupec formátu text. Také vytvoří dva sloupce pro časové značky určené pro zachycení vyvoření a editace záznamu. Více informací o migracích naleznete v průvodci "Rails Database Migrations":migrations.html.

Nyní můžete použít příkaz rake ke spuštění migrace:

<shell>
$ rake db:migrate
</shell>

Rails provede migraci a oznámí Vám, že vytvořily tabulku Posts.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. Protože pracujete implicitně v development prostředí, tento příkaz se provede nad databází definovanou v sekci +development+ v souboru +config/database.yml+.

h4. Přidání odkazu

K napojení příspěvků na domácí stránku, kterou jste už vytvořili, můžete přidat odkaz. Otevřete +app/views/home/index.html.erb+ a změňte jej takto:

<code lang="ruby">
<h1>Ahoj, Rails!</h1>
<%= link_to "Můj blog", posts_path %>
</code>

Metoda +link_to+ je jednou z pomocných funkcí views, zabudovaných v Rails. Vytvoří hypertextový odkaz z parametrů jaký text zobrazit a kam odkázat – v tomto případě cesta k příspěvkům.

h4. Práce s příspěvky v prohlížeči

Nyní už můžete začít pracovat s příspěvky. Přejděte na "http://localhost:3000":http://localhost:3000/ a klikněte na odkaz "Můj blog":

!images/posts_index.png(Posts Index screenshot)!

Toto je výsledkem vykreslení pohledu +index+. Momentálně nejsou v databázi žádné příspěvky, ale pokud kliknete na odkaz +New Post+, můžete nějaký vytvořit. Následně uvidíte, že můžete příspěvky editovat, podívat se na jejich detaily nebo je mazat. Veškerá tato aplikační logika a HTML, které se o to starají, byly vytvořeny jediným příkazem +rails generate scaffold+.

TIP: V módu development (ve kterém pracujete implicitně) Rails znovu načítá celou aplikaci při každém požadavku odeslaném prohlížečem, takže není třeba restartovat webserver.

Gratulujeme, jedete na Rails! Teď je na čase podívat se, jak to všechno funguje.

h4. Model

Soubor modelu +app/models/post.rb+ už snad nemůže být jednodušší:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

K tomu není moc co dodat - ale povšimněte si prosím, že třída +Post+ dědí od třídy +ActiveRecord::Base+. Active Record poskytuje spoustu funkcionality Vašim rails modelům zdarma, včetně základních databázových operací CRUD (Create/Vytvořit, Read/Načíst, Update/Upravit, Destroy/Odstranit), validací dat, a také sofistikovanou podporu vyhledávání a schopnost vytváření relací mezi jednotlivými modely.

h4. Přidání pár validací

Rails obsahují metody, které Vám pomůžou validovat data, která se posílají modelu. Otevřete soubor +app/models/post.rb+ a upravte jej:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

Tyto změny zajistí, že všechny příspěvky budou mít jméno (name) a titulek (title) a že titulek bude mít alespoň 5 znaků. Rails můžou validovat mnoho různých podmínek v modelu, včetně existence a unikátnosti sloupců, jejich formátu a existence asociovaných objektů.

h4. Použití konzole

Abychom si prohlídli validace v akci, můžeme použít konzoli. Konzole je nástroj příkazové řádky, který umožňuje spouštět Ruby kód v kontextu Vaší aplikace:

<shell>
$ rails console
</shell>

Když se konzole načte, můžete ji použít pro práci s modely ve Vaší aplikaci:

<shell>
>> p = Post.new(:content => "Nový příspěvek")
=> #<Post id: nil, name: nil, title: nil,
     content: "Nový příspěvek", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

Tento kód ukazuje vytvoření nové instance třídy +Post+, pokus o její uložení a obdržení návratové hodnoty +false+ (indikující, že uložení se nezdařilo) a vypsání detailu chyby.

Až budete hotovi, napište +exit+ a stiskněte +enter+ pro odchod z konzole.

TIP: Narozdíl od development web serveru, konzole nenačítá znovu kód pro každý řádek. Pokud provedete změnu v modelu zatímco konzole je otevřená, napište v konzoli +reload!+, abyste tyto změny načetli.

h4. Vypsání všech příspěvků

Nejjednodušejší místo, kde začít zkoumat funkcionalitu naší aplikace je kód, který vypíše všechny příspěvky. Otevřete soubor +app/controllers/posts_controller.rb+ a podívejte se na akci +index+:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</ruby>

+Post.all+ říká modelu +Post+, aby vrátil všechny příspěvky, které momentálně v databázi jsou. Výstupem tohoto příkazu je pole s příspěvky, které uložíme do instanční proměnné nazvané +@posts+.

TIP: Více informací o vyhledávání záznamů pomocí Active Record naleznete v průvodci "Active Record Query Interface":active_record_querying.html.

Blok +repond_to+ zpracuje HTML a XML volání této akce. Pokud přejdete na "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml, uvidíte všechny příspěvky v XML formátu. Formát HTML vyhledá view ve složce +app/views/posts/+ s názvem odpovídajícím názvu akce. Rails dají všechny instanční proměnné z akce k dispozici příslušnému view. Zde je +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

Tento pohled projde obsah pole +@posts+, aby zobrazil obsah a odkazy. Několik věcí k povšimnutí v tomto view:

* +link_to+ vytvoří hypertextový odkaz na příslušný cíl
* +edit_post_path+ a +new_post_path+ jsou helpery, které Rails poskytují jako součást REST směrování. U dalších akcí, které controller obsahuje, uvidíte mnoho dalších variací těchto helperů.

NOTE. V předchozích verzích Rails jste museli použít +&lt;%=h post.name %&gt;+ aby bylo případný HTML kód transformován, než bude vložen do stránky. V Rails 3.0 je tato operace implicitní. Abyste získali netransformované HTML, použijte +&lt;%= raw post.name %&gt;+.

TIP: Více detailů k zobrazovacímu procesu najdete v průvodci "Layouts and Rendering in Rails":layouts_and_rendering.html.

h4. Ůprava layoutu

View je jen část příběhu, jak je se HTML zobrazí ve Vašem prohlížeči. Rails také používají konecpt layoutů, což jsou konteinery pro views. Když Rails zobrazují view v prohlížeči, vkládají HTML kód z view souboru do HTML kódu layoutu. V předchozích verzích Rails příkaz +rails generate scaffold+ automaticky vytvořil samostatný layout pro příslušný controller, například +app/views/layouts/posts.html.erb+ pro posts controller. Tohle však bylo v Rails 3.0 změněno. Vytváří se jeden +layout+ pro celou aplikaci a je uložen jako soubor +app/views/layouts/application.html.erb+. Otevřete tento layout ve Vašem editoru a upravte tag +body+:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tag %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Když teď znovu načtete stránku +/posts+, uvidíte, že má šedé pozadí. Stejné šedé pozadí bude použito ve všech ostatních views.

h4. Vytváření nových příspěvků

Vytvoření nového příspěvku zahrnuje dvě akce. První je akce +new+, která vytvoří prázdný objekt +Post+:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

View +new.html.erb+ zobrazí uživateli tento prázdný příspěvek:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

Řádek +&lt;%= render 'form' %&gt;+ je naším úvodem do parciálních šablon v Rails (dále _partials_). Partial je útržek kódu HTML a Ruby, který může být vícenásobně použit na různých místech. V tomto případě je formulář pro vytvoření nového příspěvku prakticky totožný s formulářem pro úpravu příspěvků – oba mají textová pole pro název a titlek textarea pro obsah příspěvku s tlačítkem pro vytvoření nového příspěvku nebo úpravu stávajícího.

Když se podíváte na soubor +views/posts/_form.html.erb+, uvidíte následující:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Tento partial obdrží všechny instanční proměnné definované při volání view, takže v tomto případě controller vloží nový objekt příspěveku to proměnné +@post+ a proto je k dispozici jak ve view tak v partialu jako +@post+.

Více informací k partials najdete v průvodci "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials.

Blok +form_for+ se používa pro vytvoření formuláře. Uvnitř tohoto bloku máte přístup k metodám pro vytvoření různých ovládacích prvků. Například, +f.text_field :name+ řekne Rails, aby ve formuláři vytvořili textové a navázali ho na atribut +name+ instance, která se zobrazuje. Tyhle metody můžete používat jenom na atributech modelu, na kterém je formulář založen (v tomhle případě +name+, +title+, a +content+). Rails upřednostňují používání +form_for+ před psaním čistého HTML protože kód je stručnější, a protože explicitně váže formulář na danou instanci modelu.

Blok +form_for+ je tak chytrý, že přijde na to, jestli děláte akci _New Post_ nebo _Edit Post_, a vhodně nastaví tagy +action+ pro formulář a text odesílacího tlačítka v HTML výstupu.

TIP: Jestli potřebujete vytvořit HTML formulář, který zobrazuje libovolné prvky, které nejsou vázané na model, měli by jste použít metodu +form_tag+, která poskytuje zjednodušený přístup pro vytváření formulářů, které nejsou nutně vázány na instance modelu.

Když uživatel klikne v tomhle formuláři na tlačítko +Create Post+, prohlížeč pošle informace zpátky metodě +create+ patříci kontrolleru (Rails ví, že má volat metodu +create+ protože formulář se posílá HTTP POST požadavkem; to je jedna z konvencí, kterou jsem už zmínil):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

The +create+ action instantiates a new Post object from the data supplied by the user on the form, which Rails makes available in the +params+ hash. After successfully saving the new post, +create+ returns the appropriate format that the user has requested (HTML in our case). It then redirects the user to the resulting post +show+ action and sets a notice to the user that the Post was successfully created.

If the post was not successfully saved, due to a validation error, then the controller returns the user back to the +new+ action with any error messages so that the user has the chance to fix the error and try again.

The "Post was successfully created." message is stored inside of the Rails +flash+ hash, (usually just called _the flash_) so that messages can be carried over to another action, providing the user with useful information on the status of their request. In the case of +create+, the user never actually sees any page rendered during the Post creation process, because it immediately redirects to the new Post as soon Rails saves the record. The Flash carries over a message to the next action, so that when the user is redirected back to the +show+ action, they are presented with a message saying "Post was successfully created."

h4. Zobrazování jednotlivých příspěvků

Když kliknete na odkaz +show+ pro příspěvek na stránke index, přesune vás to na URL jako +http://localhost:3000/posts/1+. Rails tohle interpretuje jako volání akce +show+ pro resource a pošle +1+ jako parametr +:id+. Tady je akce +show+:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +show+ action uses +Post.find+ to search for a single record in the database by its id value. After finding the record, Rails displays it by using +show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
<% end %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial, this time however, the form will do a PUT action to the PostsController and the submit button will display "Update Post"

Submitting the form created by this view will invoke the +update+ action within the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to the +edit+ view to correct them.

h4. Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

h3. Přidání druhého modelu

Teď, když už víte, jak model vytvořený scaffoldem vypadá, je čas přidat do aplikace druhý model. Ten bude sloužit na správu komentářů k příspěvkům na blogu.

h4. Vygenerování modelu

Modely v Rails používají název v jednotném čísle a k nim přináležíci tabulky v databáze používají pro název číslo množné. Model pro komentáře bude mít podle konvencí název Comment. I když nechcete použít všechny současti vygenerované scaffoldem, většina Rails vývojářů používa generátory pro věci jako modely a kontrolery. Pro vytvoření modelu, spusťte tenhle příkaz v konzole:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

Tenhle příkaz vygeneruje čtyři soubory:

* +app/models/comment.rb+ - Model
* +db/migrate/20100207235629_create_comments.rb+ - Migrace
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - Příprava pro testy.

Nejdřív se podívejme na +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Tohle je hodně podobné modelu +post.rb+ který jste viděli dříve. Rozdílny je řádek +belongs_to :post+, který nastaví Active Record _vazbu_. O vazbách se naučíte víc v nasledující kapitole tohoto průvodce.

Jako přídavek k modelu, Rails vytvořili i migraci, která vybuduje příslušnou databázovou tabulku:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

Řádek +t.references+ nastaví cizí klíč pro vazbu mezi těmito dvěma modely. Teď spustěte migraci:

<shell>
$ rake db:migrate
</shell>

Rails jsou dostatečně chytrý, takže spustí jenom migrace, které ještě nebyly spouštěné pro aktuální databázi, takže v tomhle případě uvidíte jenom:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Provázání modelů

Vazby v Active Record vám dovolují snadno deklarovat vztahy mezi dvěma modely. V případě komentářů a příspěvků, můžete zapsat vztah tímhle způsobem:

* Každý komentář patří jednomu příspěvku
* Jeden příspěvek může mít vícero komentářů

Ve skutečnosti, tohle je hodně podobné zápisu, který Rails používají pro deklaraci této vazby. Už jste viděli řádek kódu uvnitř modelu Comment, který udělal každý komentář patřící příspěvku::

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Budete potřebovat upravit soubor +post.rb+ abyste přidali druhou stranu vazby:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

Tyhle dvě deklarace zapnou velký kus automatického chování. Například, když máte instanční proměnnou +@post+ obsahující příspěvek, můžete jednoduše získat všechny komentáře patřící tomuto příspěvku jako pole +@post.comments+.

TIP: Pro víc informací o Active Record vazbách se podívejte na průvodce "Active Record Associations":association_basics.html.

h4. Přidání routy pro komentáře

Jako s +home+ kontrolerem, musíme přidat routu, aby Rails vědeli kam se chceme dostat pro zobrazení komentářů. Otevřete znovu soubor +config/routes.rb+ , uvidíte záznam, který byl přidán automaticky pro +posts+ scaffold generátorem, +resources :posts+, upravte ho nasledovně:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

To vytvoří +comments+ jako _vnořené zdroje_ pro +posts+. Tohle je další část zachycení hierarchického vztahu, který existuje mezi příspěvky a komentáři.

TIP: Pro víc informací o routingu se podívejte na průvodce "Rails Routing from the Outside In":routing.html.

h4. Vygenerování kontroleru

Když máme hotový model, můžeme soustředit svou pozornost na vytvoření příslušného kontroleru. Pro to máme opět k dispozici generátor:

<shell>
$ rails generate controller Comments
</shell>

To vytvoří čtyři soubory a jeden prázdny adresář:

* +app/controllers/comments_controller.rb+ - Kontroler
* +app/helpers/comments_helper.rb+ - Soubor s pomocnými metodami pro zobrazení
* +test/functional/comments_controller_test.rb+ - Funkční testy pro kontroler
* +test/unit/helpers/comments_helper_test.rb+ - Jednotkový test pro helper
* +app/views/comments/+ - Tady jsou uloženy zobrazení

Jako při jakýmkoli blogu, naši čtenáři budou chtít vytvářet jejich komentáře hned po přečtení příspěvku. Jakmile komentář přidají, budou přesměrování na zobrazení příspěvku, aby viděli jejich přidaný komentář . Kvůli tomu náš +CommentsController+ poskytuje metodu pro vytváření komentářů a mazaní komentářů, které jsou považovány za SPAM.

Nejdřív dáme dohromady šablonu pro zobrazení příspěvku (+/app/views/posts/show.html.erb+) abychom mohli přidávat komentáře:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Přidat komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpátky na příspěvky', posts_path %> |
</erb>

Tohle přidá na stránku zobrazení příspěvku formulář pro přidání nového komentáře, který zavolá +CommentsController+ +create+ akci, takže ho pojďme vytvořit:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

Uvidíte zde trochu víc komplexity v porovnání s kontrolerem pro příspěvky. To je vedlejší efekt vnoření, které jste nastavili; každý požadavek pro komentář si musí ukládat informaci o tom, ke kterému příspěvku je přiřazen, proto ta začáteční find akce na modeli Post - pro získaní příspevku.

Kromě toho, kód využíva některé metody dostupné pro vazby. Používáme metodu +create+ na +@post.comments+ pro vytvoření a uložení komentáře. To automaticky nalinkuje komentář tak, aby patřil danému příspěvku.

Jakmile jsme přidali nový komentář, pošleme uživatele zpátky na originální příspěvek použitím helpru +post_path(@post)+. Jak jsme už viděli, tohle zavolá +show+ akci na +PostsController+ který následně zobrazí šablonu +show.html.erb+. Tam chceme ten komentář zobrazit, tak to přidejme do +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Komentáře</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Komentátor:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Komentář:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Přidejte komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Úprava příspěvku', edit_post_path(@post) %> |
<%= link_to 'Zpátky na příspěvky', posts_path %> |
</erb>

Teď můžete přidávat příspěvky a komentáře do vašeho blogu mít je zobrazené na správných místech.

h3. Refactoring

Teď máme fungující články a jejich komentování. Když se ale podíváme do šablony +app/views/posts/show.html.erb+, zjistíme že kód je dlouhý a nešikovný. Můžeme použít partials (parciální/částečné šablony) k lepší čitelnosti kódu.

h4. Vykreslení parciálních kolekcí

Nejdřív vytvoříme z kódu pro zobrazování komentáře u článku parciální šablonu. Vytvoříme soubor +app/views/comments/_comment.html.erb+ a do něj vložíme nasledující kód:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Potom můžeme v šabloně +app/views/posts/show.html.erb+ udělat změny tak, aby vypadal následovně:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Jméno:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidat komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once for each comment that is in the +@post.comments+ collection.  As the +render+ method iterates over the <tt>@post.comments</tt> collection, it assigns each comment to a local variable named the same as the partial, in this case +comment+ which is then available in the partial for us to show.

h4. Vykreslední partial formuláře

Pojďme také přesunout sekci „nový komentář“ do vlastního partialu. Vytvořte soubor +app/views/comments/_form.html.erb+ a do něj vložte:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Pak změňte +app/views/posts/show.html.erb+ do následující podoby:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Druhý render pouze definuje částečnou šablonu kterou vykreslit - <tt>comments/form</tt>. Rails jsou dost chytré na to, aby poznaly lomítko v řetězci a pochopily že chcete vykreslit šablonu <tt>_form.html.erb</tt> ze složky <tt>app/views/comments</tt>.

Objekt +@post+ je dostupný v kterékoliv parciální šabloně, protože je definován jako instanční proměnná.

h3. Mazání komentářů

Další důležitou funkcí na blogu je možnost mazat SPAMové komentáře. K tomu potřebujeme implemetovat nějaký ten odkaz ve view a +DELETE+ akci v +CommentsController+.

Nejprve tedy přidejme odkaz na smazání v +app/views/comments/_comment.html.erb+ partialu:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Kliknutí na tento nový odkaz "Destroy Comment" spustí akci <tt>DELETE /posts/:id/comments/:id</tt> v našem +CommentsController+, který pak podle ní najde komentář, který chceme vymazat, takže přidejme akci destroy do našeho controlleru:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

Akce +destroy+ najde příspěvek na který se díváme, vyhledá kometář v kolekci <tt>@post.comments</tt> a pak ho vymaže z databáze a pošle nás zpět na 'show' akci příspěvku.


h4. Mazání návazných objektů

Pokud vymažete příspěvek, pak návazné komentáře je také třeba vymazat. Jinak budou prostě jen zabírat místo v databázi. Rails vám k tomutu účelu umožňuje použít možnost +dependent+ na relaci mezi modely. Upravte Post model v +app/models/post.rb+ následovně:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Bezpečnost

Kdybyste nyní poskytli veřejný přístup ke svému blogu, kdokoliv by byl schopen přidat, upravovat a mazat příspěvky a komentáře.

Rails nabízejí velmi jednoduchý HTTP autentizační systém, který bude v této situaci hezky fungovat. Nejprve umožníme jednoduchou HTTP autentizaci v našem controlleru <tt>app/controllers/application_controller.rb</tt>:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery

  private

  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end

end
</ruby>

Můžete samozřejmě změnit uživatelské jméno a heslo na cokoliv chcete. Tuto metodu dáváme do +ApplicationController+ aby byla přístupná všem našim controllerům.

Následně potřebujeme mít v +PostsController+ nějaký způsob blokování přístupu k různým akcím pokud uživatel není autentizován. Zde můžeme použít Rails metodu <tt>before_filter</tt>, která nám umožňuje určit, že Rails musí spustit metodu a až následně povolit přístup k vyžádané akci, pokud to tato metoda povolí.

Použítí before filteru deklarujeme na začátku našeho +PostController+. V tomto případě chceme, aby byl uživatel přihlášen u každé akce, kromě +index+ a +show+, takže napíšeme:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

Také mazání komentářů chceme povolit pouze přihlášeným uživatelům, takže v +CommentsController+ napíšeme:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Nyní pokud se pokusíte vytvořit příspěvek, uvítá vás základní HTTP autentizační výzva

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. Vytváření Multi-Model Formuláře

Další vlastností průměrného blogu je možnost štítkovat příspěvky. Pro jeji implementaci potřebuje vaše aplikace spolupracovat s více objekty v jednom formuláři. Rails poskytují podporu pro vnořené formuláře.

Na ukázku přidáme podporu pro přidávání několika štítků každému příspěvku přímo ve formuláři, kde vytváříme příspěvek. Nejprve vytvořte nový model, který bude reprezentovat štítky:

<shell>
$ rails generate model tag name:string post:references
</shell>

Opět, spustěte migrace pro vytvoření tabulky v databázi:

<shell>
$ rake db:migrate
</shell>

Dále, pozměňte soubor +post.rb+ abyste vytvořili druhou stranu vazby a dali Rails věďet, (přes +accepts_nested_attributes_for+ makro) že hodláte měnit štítky přes příspěvky:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

Volba +:allow_destroy+ při deklaraci nested attribute říka Rails ať zobrazí checkbox "Odstranit" v šabloně, kterou vytvoříme za chvíli. Volba +:reject_if+ zabraňuje ukládání nových štítků, které nemají vyplněny žádne atributy.

Upravíme +views/posts/_form.html.erb+ pro zobrazení partial view pro štítky:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> zabránili tomuto příspevku, aby byl uložen:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Povšimněte si, že jsme změnili +f+ v +form_for(@post) do |f|+ na +post_form+ abychom to udělali jednodušší na porozumění.

Tenhle příklad ukazuje další možnost zobrazovacího pomocníka, díky které můžeme předat lokálni proměnnou, v tomhle případě chceme, aby lokálni proměnná v častečné šabloně +form+ odkazovala na objekt +post_form+.

Také jsme přidali <tt>@post.tags.build</tt> na vrchu formuláře, tím se ujistíme, že máme připraven nový štítek pro vyplnění jeho jména uživatelem. Jestli nevytváříte nový štítek, pak se formulář nezobrazí, ponevač neexistuje nový objekt štítku pro vytvoření.

Těď vytvořte adresáŕ <tt>app/views/tags</tt> a v něm soubor <tt>_form.html.erb</tt> který obsahuje formulář pro štítek:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Štítek:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Odstranit:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Nakonec upravíme <tt>app/views/posts/show.html.erb</tt> šablonu pro zobrazování našich štítků.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<p>
  <b>Štítky:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidejte komentář:</h2>
<%= render "comments/form" %>


<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

S těmito změnami můžete upravovat příspevky svého blogu a štítky přímo ve stejným zobrazení.


Jelikož je způsob <tt>@post.tags.map { |t| t.name }.join(", ")</tt> nešikovný, můžeme si poradit použitím helper metody.

h3. Zobrazovací Helpery

Zobrazovací helpery se nacházejí v <tt>app/helpers</tt> a poskytují malé kousky znovupoužitelného kódu pro naše pohledy. V našem případě potřebujeme metodu, která zřetězí několik objektů použitím jejich názvu a spojí je čárkami. Jelikož je tahle helper metoda použita v šablone Post show, umístnime ji do PostsHelper.

Otevřte <tt>app/helpers/posts_helper.rb</tt> a přidejte nasledovné:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

Teď můžete upravit zobrazení v <tt>app/views/posts/show.html.erb</tt> aby vypadalo takhle:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<p>
  <b>Štítky:</b>
  <%= join_tags(@post) %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidat komentář:</h2>
<%= render "comments/form" %>


<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

h3. Co dál?

Teď, když jste vytvořili svou první Rails aplikaci, nemělo by vám dělat problém vylepšit si ji a experimentovat s ní. Nemusíte však dělat všechno bez nápovědy. Když budete potřebovat pomoc ohledně vývoje v Rails, neváhejte použít tyhle zdroje:

* The "Ruby on Rails guide":index.html
* The "Ruby on Rails tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails kanál na irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails také nabízí vstavanou nápovědu, kterou si můžete vygenerovat použitím nástroje rake v příkazovém řádku:

* Spuštění +rake doc:guides+ uloží kompletní kopii Rails Guides do adresáře +doc/guides+ vaši applikace. Otevřte +doc/guides/index.html+ ve svém prohlížeči pro jeji prohlížení.
* Spuštění +rake doc:rails+ uloží kompletní kopii API dokumentace pro Rails do adresáře +doc/api+ vaši aplikace. Otevřte +doc/api/index.html+ ve svém prohlížeči pro jeji prohlížení.

h3. Vychytávky pro konfiguraci

Nejjednoduchší způsub, jak pracovat s Rails je ukládat všechna externí data ve formáte UTF-8. Jestli ne, Ruby knihovny a Rails budou často schopni konvertovat vaše nativní data do UTF-8, ale ne vždy to funguje spolehlivě, takže je lepší ujistit se, že všechna externí data jsou v UTF-8.

Jestli jste v něčem z toho udělali chybu, nejčastějsí příznak je černý diamant s otazníkem vevnitř zobrazujíci se v prohlížeči. Další častý příznak je znak jako například "Ã¼" zobrazujíci se namísto "ü". Rails dělají několik interních kroků, aby zmírnili příčiny těchto problémů, které můžou být automaticky zjištěny a opraveny. Nicméně, jestli máte data, která nejsou uložena v UTF-8, může se stát, že se objeví problémy, které nemůžou být automaticky zjištěny a opraveny v Rails.

Dva časté zdroje dat, která nejsou v UTF-8:
* Váš textový editor: Většina textových editorů (jako například TextMate), ukládá soubory
  předvoleně v UTF-8. Jestli to váš editor nedělá, může se stát, že speciální znaky, které
  použijete ve vašich šablonách (například é), se v prohlížeči zobrazí jako diamant
  s otazníkem vevnitř. To se taky týká vašich I18N překladových souború. Většina editorů,
  které neukládají předvoleně do UTF-8 (jako například některé verze Dreamwaver-u) poskytují
  způsob, jak změnit předvolené ukládání na UTF-8. Udělejte to.
* Vaše databáza. Rails implicitně konvertují data z vaši databáze při výběru/zápisu.
  Takže jestli vaše databáza nepoužívá interně UTF-8, nemusí být schopna ukládat všechny znaky,
  které uživatelé zadají. Například, jestli vaše databáza interně používa Latin-1 a uživatelé
  zadají Ruské, Hebrejské nebo Japonské znaky, data se navždy stratí v momentě, kdy se dostanou
  do databázy. Jestli to je možné, používejte UTF-8 jako interní úložiště vaši databáze.

h3. Seznam změn

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2

* August 30, 2010: Minor editing after Rails 3 release by "Joost Baaij":http://www.spacebabies.nl
* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)
